<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Article Certification · ExBoot</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
  <style>
    :root {
      color-scheme: dark;
      --bg: #040711;
      --glass: rgba(14, 19, 33, 0.72);
      --glass-strong: rgba(18, 24, 42, 0.86);
      --border: rgba(148, 163, 184, 0.22);
      --accent: #47f5c0;
      --accent-strong: #7cf7ff;
      --text-primary: #f8fafc;
      --text-muted: rgba(226, 232, 240, 0.72);
      --radius-lg: 22px;
      --radius-md: 16px;
      --shadow: 0 18px 40px rgba(7, 12, 24, 0.45);
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      min-height: 100vh;
      font-family: 'Inter', 'Segoe UI', system-ui, -apple-system, sans-serif;
      background: radial-gradient(circle at 12% 18%, rgba(124,247,255,0.15), transparent 55%),
                  radial-gradient(circle at 85% 20%, rgba(244,114,182,0.18), transparent 60%),
                  radial-gradient(circle at 40% 80%, rgba(71,245,192,0.18), transparent 65%),
                  var(--bg);
      color: var(--text-primary);
      padding: 2.5rem clamp(1.2rem, 4vw, 3rem);
      display: flex;
      justify-content: center;
    }

    .hidden {
      display: none !important;
    }

    main {
      width: min(1100px, 100%);
      display: grid;
      gap: 1.8rem;
    }

    header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: var(--glass);
      border: 1px solid var(--border);
      border-radius: var(--radius-lg);
      padding: 1.4rem 1.8rem;
      box-shadow: var(--shadow);
      backdrop-filter: blur(14px) saturate(160%);
    }

    header h1 {
      margin: 0;
      font-size: clamp(1.5rem, 3vw, 2rem);
      font-weight: 600;
      letter-spacing: 0.01em;
    }

    header a {
      color: var(--accent-strong);
      text-decoration: none;
      font-weight: 500;
      border: 1px solid rgba(124, 247, 255, 0.25);
      padding: 0.5rem 1.1rem;
      border-radius: 999px;
      transition: background 0.3s ease, transform 0.3s ease;
    }

    header a:hover {
      background: rgba(124, 247, 255, 0.08);
      transform: translateY(-2px);
    }

    section {
      background: var(--glass);
      border: 1px solid var(--border);
      border-radius: var(--radius-lg);
      padding: clamp(1.3rem, 3vw, 2rem);
      box-shadow: var(--shadow);
      backdrop-filter: blur(12px) saturate(150%);
    }

    .grid-two {
      display: grid;
      gap: 1.5rem;
      grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
    }

    .field-group {
      display: flex;
      flex-direction: column;
      gap: 0.6rem;
    }

    .field-group .sub-label {
      font-size: 0.8rem;
      color: var(--text-muted);
      font-weight: 500;
      letter-spacing: 0.01em;
    }

    label {
      display: block;
      font-weight: 500;
      margin-bottom: 0.6rem;
      color: var(--text-muted);
    }

    input[type="search"],
    select,
    input[type="url"] {
      width: 100%;
      background: rgba(12, 17, 31, 0.86);
      color: var(--text-primary);
      border: 1px solid rgba(148, 163, 184, 0.28);
      border-radius: var(--radius-md);
      padding: 0.75rem 1rem;
      font-size: 0.95rem;
      transition: border 0.3s ease, box-shadow 0.3s ease;
    }

    input:focus,
    select:focus {
      outline: none;
      border-color: rgba(71, 245, 192, 0.6);
      box-shadow: 0 0 0 3px rgba(71, 245, 192, 0.15);
    }

    select {
      appearance: none;
      background-image: url('data:image/svg+xml;utf8,<svg fill="white" height="14" viewBox="0 0 24 24" width="14" xmlns="http://www.w3.org/2000/svg"><path d="M7 10l5 5 5-5z"/></svg>');
      background-repeat: no-repeat;
      background-position: right 0.8rem center;
      background-size: 0.8rem;
      padding-right: 2.5rem;
    }

    .actions {
      display: flex;
      flex-direction: column;
      gap: 0.9rem;
      margin-top: 1.4rem;
    }

    .primary-actions,
    .secondary-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 0.8rem;
      align-items: center;
    }

    .secondary-actions {
      justify-content: space-between;
    }

    .secondary-actions .image-toggle {
      margin-left: auto;
    }

    .image-toggle {
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
      font-size: 0.9rem;
      color: var(--text-muted);
      padding-left: 0.2rem;
    }

    .image-toggle input[type="checkbox"] {
      width: 1.05rem;
      height: 1.05rem;
      accent-color: var(--accent);
      cursor: pointer;
    }

    button {
      cursor: pointer;
      border: none;
      border-radius: 999px;
      padding: 0.75rem 1.6rem;
      font-size: 0.95rem;
      font-weight: 600;
      transition: transform 0.25s ease, box-shadow 0.25s ease, opacity 0.25s ease;
    }

    button.is-loading {
      position: relative;
      pointer-events: none;
      opacity: 0.75;
    }

    button.is-loading::after {
      content: '';
      position: absolute;
      right: 1.2rem;
      top: 50%;
      width: 0.9rem;
      height: 0.9rem;
      margin-top: -0.45rem;
      border-radius: 999px;
      border: 2px solid rgba(248, 250, 252, 0.35);
      border-top-color: var(--accent);
      animation: button-spin 0.8s linear infinite;
    }

    @keyframes button-spin {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }

    button.primary {
      background: linear-gradient(135deg, rgba(71,245,192,0.85), rgba(124,247,255,0.9));
      color: #041221;
      box-shadow: 0 12px 30px rgba(124, 247, 255, 0.18);
    }

    button.primary:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      box-shadow: none;
    }

    button.secondary {
      background: rgba(17, 24, 39, 0.75);
      color: var(--text-primary);
      border: 1px solid rgba(124,247,255,0.25);
    }

    button.playbook {
      background: rgba(10, 14, 28, 0.92);
      color: var(--text-primary);
      border: 1px solid rgba(124, 247, 255, 0.28);
      box-shadow: 0 12px 30px rgba(4, 12, 24, 0.4);
    }

    button:hover:not(:disabled) {
      transform: translateY(-2px);
    }

    .status-wrapper {
      margin-top: 0.8rem;
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }

    .status {
      margin: 0;
      min-height: 1.2rem;
      font-size: 0.9rem;
      color: var(--text-muted);
    }

    .progress {
      display: flex;
      flex-direction: column;
      gap: 0.35rem;
    }

    .progress-track {
      width: 100%;
      height: 0.6rem;
      background: rgba(148, 163, 184, 0.18);
      border-radius: 999px;
      overflow: hidden;
    }

    .progress-bar {
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg, var(--accent), var(--accent-strong));
      border-radius: 999px;
      transition: width 0.35s ease;
    }

    .progress-bar.error {
      background: linear-gradient(90deg, #f87171, #fb7185);
    }

    .progress-label {
      font-size: 0.85rem;
      color: var(--text-muted);
      min-height: 1rem;
    }

    .progress-label.error {
      color: #fda4af;
    }

    .article-output {
      background: var(--glass-strong);
      border-radius: var(--radius-lg);
      border: 1px solid rgba(124, 247, 255, 0.2);
      padding: 1.5rem;
      white-space: pre-wrap;
      line-height: 1.65;
      max-height: 540px;
      overflow-y: auto;
    }

    .json-output {
      background: rgba(12, 17, 31, 0.86);
      border: 1px solid rgba(124, 247, 255, 0.18);
      border-radius: var(--radius-md);
      padding: 1.2rem 1.4rem;
      white-space: pre-wrap;
      line-height: 1.6;
      min-height: 160px;
      max-height: 400px;
      overflow-y: auto;
      font-family: 'JetBrains Mono', 'Fira Code', 'SFMono-Regular', Menlo, Consolas, monospace;
      font-size: 0.9rem;
    }

    .social-output {
      display: grid;
      gap: 1.3rem;
      grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
    }

    .social-item {
      display: flex;
      flex-direction: column;
      gap: 0.8rem;
    }

    .social-output h3 {
      margin: 0 0 0.6rem;
      font-size: 1rem;
      font-weight: 600;
      color: var(--accent-strong);
    }

    .social-block {
      background: rgba(12, 17, 31, 0.86);
      border: 1px solid rgba(124, 247, 255, 0.18);
      border-radius: var(--radius-md);
      padding: 1.1rem 1.2rem;
      min-height: 160px;
      white-space: pre-wrap;
      line-height: 1.55;
    }

    .block-actions {
      display: flex;
      justify-content: flex-end;
    }

    .block-actions button {
      min-width: 140px;
    }

    .article-output h2,
    .article-output h3 {
      color: var(--accent-strong);
    }

    @media (max-width: 720px) {
      body {
        padding: 1.8rem 1.1rem;
      }

      header {
        flex-direction: column;
        align-items: flex-start;
        gap: 0.8rem;
      }

      header a {
        align-self: flex-end;
      }
    }
  </style>
</head>
<body>
  <main>
    <header>
      <div>
        <h1>Article de certification piloté par IA</h1>
        <p style="margin:0;color:var(--text-muted);max-width:38rem">Composez un article complet en sélectionnant un provider, une certification et le lien du test partagé Examboot. L'intelligence artificielle rédige automatiquement le contenu prêt à être publié.</p>
      </div>
      <a href="{{ url_for('home') }}">← Retour</a>
    </header>

    <section>
      <h2 style="margin-top:0;margin-bottom:1.5rem;font-weight:600;font-size:1.2rem;letter-spacing:0.01em;color:var(--accent-strong)">1. Sélectionnez la certification</h2>
      <div class="grid-two">
        <div class="field-group">
          <label for="providerSelect">Providers disponibles</label>
          <label class="sub-label" for="providerSearch">Recherche provider</label>
          <input type="search" id="providerSearch" placeholder="Rechercher un provider" autocomplete="off">
          <select id="providerSelect">
            <option value="">Choisir un provider…</option>
          </select>
        </div>
        <div class="field-group">
          <label for="certSelect">Certifications shortlistées</label>
          <label class="sub-label" for="certSearch">Recherche certification</label>
          <input type="search" id="certSearch" placeholder="Rechercher une certification" autocomplete="off" disabled>
          <select id="certSelect" disabled>
            <option value="">Choisir une certification…</option>
          </select>
        </div>
        <div class="field-group">
          <label for="topicTypeSelect">Type de sujet</label>
          <select id="topicTypeSelect">
            <option value="">Choisir un type de sujet…</option>
            {% for topic in topic_types %}
            <option value="{{ topic.value }}">{{ topic.label }}</option>
            {% endfor %}
          </select>
        </div>
        <div class="field-group">
          <label for="examUrl">Lien du test partagé Examboot</label>
          <input type="url" id="examUrl" placeholder="https://" autocomplete="off">
        </div>
      </div>
      <div class="actions">
        <div class="primary-actions">
          <button class="primary" id="generateArticleBtn">Générer l'article</button>
          <button class="secondary" id="generateTweetBtn">Générer le tweet</button>
          <button class="secondary" id="generateLinkedinBtn">Générer le post LinkedIn</button>
        </div>
        <div class="secondary-actions">
          <button class="playbook" id="runPlaybookBtn" disabled>Run playbook</button>
          <label class="image-toggle">
            <input type="checkbox" id="addImageCheckbox">
            <span>Ajouter une image</span>
          </label>
        </div>
      </div>
      <div class="status-wrapper">
        <div class="status" id="statusArea"></div>
        <div class="progress hidden" id="runbookProgress">
          <div class="progress-track">
            <div class="progress-bar" id="runbookProgressBar"></div>
          </div>
          <div class="progress-label" id="runbookProgressLabel"></div>
        </div>
      </div>
    </section>

    <section>
      <h2 style="margin-top:0;margin-bottom:1rem;font-weight:600;font-size:1.2rem;letter-spacing:0.01em;color:var(--accent-strong)">2. Article généré</h2>
      <div class="article-output" id="articleOutput">L'article généré apparaîtra ici après soumission du formulaire.</div>
      <div class="block-actions">
        <button class="secondary" id="publishArticleBtn" disabled>Publier</button>
      </div>
    </section>

    <section id="certBriefSection" class="hidden">
      <h2 style="margin-top:0;margin-bottom:0.6rem;font-weight:600;font-size:1.2rem;letter-spacing:0.01em;color:var(--accent-strong)">3. Résumé JSON de la certification</h2>
      <p style="margin-top:0;margin-bottom:1rem;color:var(--text-muted);font-size:0.9rem">Disponible uniquement lorsque le type de sujet « Certification presentation » est sélectionné. Génère et publie le JSON dans le champ <code>art</code> de la certification.</p>
      <div class="json-output" id="certBriefOutput">Le JSON généré apparaîtra ici lorsque disponible.</div>
      <div class="block-actions" style="gap:0.6rem;justify-content:flex-end;flex-wrap:wrap">
        <button class="secondary" id="generateBriefBtn">Générer le JSON</button>
        <button class="secondary" id="publishBriefBtn" disabled>Publier le JSON</button>
      </div>
    </section>

    <section>
      <h2 style="margin-top:0;margin-bottom:1rem;font-weight:600;font-size:1.2rem;letter-spacing:0.01em;color:var(--accent-strong)">4. Annonces sociales</h2>
      <div class="social-output">
        <div class="social-item">
          <h3>Tweet</h3>
          <div class="social-block" id="tweetOutput">Le tweet généré apparaîtra ici après l'action correspondante.</div>
          <div class="block-actions">
            <button class="secondary" id="publishTweetBtn" disabled>Publier</button>
          </div>
        </div>
        <div class="social-item">
          <h3>Post LinkedIn</h3>
          <div class="social-block" id="linkedinOutput">Le post LinkedIn généré apparaîtra ici après l'action correspondante.</div>
          <div class="block-actions">
            <button class="secondary" id="publishLinkedinBtn" disabled>Publier</button>
          </div>
        </div>
      </div>
    </section>
  </main>

  <script>
    const providerSearch = document.getElementById('providerSearch');
    const providerSelect = document.getElementById('providerSelect');
    const certSearch = document.getElementById('certSearch');
    const certSelect = document.getElementById('certSelect');
    const examUrlInput = document.getElementById('examUrl');
    const topicTypeSelect = document.getElementById('topicTypeSelect');
    const statusArea = document.getElementById('statusArea');
    const generateArticleBtn = document.getElementById('generateArticleBtn');
    const generateTweetBtn = document.getElementById('generateTweetBtn');
    const generateLinkedinBtn = document.getElementById('generateLinkedinBtn');
    const runPlaybookBtn = document.getElementById('runPlaybookBtn');
    const publishArticleBtn = document.getElementById('publishArticleBtn');
    const publishTweetBtn = document.getElementById('publishTweetBtn');
    const publishLinkedinBtn = document.getElementById('publishLinkedinBtn');
    const articleOutput = document.getElementById('articleOutput');
    const tweetOutput = document.getElementById('tweetOutput');
    const linkedinOutput = document.getElementById('linkedinOutput');
    const addImageCheckbox = document.getElementById('addImageCheckbox');
    const certBriefSection = document.getElementById('certBriefSection');
    const certBriefOutput = document.getElementById('certBriefOutput');
    const generateBriefBtn = document.getElementById('generateBriefBtn');
    const publishBriefBtn = document.getElementById('publishBriefBtn');
    const runbookProgress = document.getElementById('runbookProgress');
    const runbookProgressBar = document.getElementById('runbookProgressBar');
    const runbookProgressLabel = document.getElementById('runbookProgressLabel');

    let providers = [];
    let certifications = [];
    let isLoading = false;

    const DEFAULT_ARTICLE_TEXT = articleOutput.textContent;
    const DEFAULT_TWEET_TEXT = tweetOutput.textContent;
    const DEFAULT_LINKEDIN_TEXT = linkedinOutput.textContent;
    const DEFAULT_BRIEF_TEXT = certBriefOutput.textContent;

    let currentArticle = '';
    let currentTweetDraft = '';
    let currentLinkedinDraft = '';
    let currentBriefData = null;
    let currentBriefText = '';

    publishArticleBtn.disabled = true;

    function renderSocialBlock(element, text, published, statusCode, error, emptyMessage, imageName) {
      const hasText = Boolean(text && text.trim());
      if (!hasText) {
        if (error) {
          element.textContent = `${emptyMessage}\n\nErreur : ${error}`;
        } else {
          element.textContent = emptyMessage;
        }
        return;
      }

      const displayText = text.trim();
      const metadata = [];
      if (imageName) {
        metadata.push(`Image : ${imageName}`);
      }

      let statusText = published ? 'Statut : Publié ✅' : 'Statut : Non publié';
      if (typeof statusCode === 'number' && statusCode !== 200) {
        statusText += ` (${statusCode})`;
      }
      if (!published && error) {
        statusText += ` – ${error}`;
      }
      metadata.push(statusText);

      element.textContent = `${displayText}\n\n${metadata.join('\n')}`;
    }

    function getSelectionPayload() {
      const providerId = providerSelect.value;
      const certificationId = certSelect.value;
      const examUrl = examUrlInput.value.trim();
      const topicType = topicTypeSelect.value;

      if (!providerId || !certificationId || !examUrl || !topicType) {
        return null;
      }

      return {
        provider_id: providerId,
        certification_id: certificationId,
        exam_url: examUrl,
        topic_type: topicType
      };
    }

    function updateActionAvailability() {
      const isCertPresentation = topicTypeSelect.value === 'certification_presentation';
      certBriefSection.classList.toggle('hidden', !isCertPresentation);

      if (isLoading) {
        return;
      }
      const hasSelection = Boolean(getSelectionPayload());
      generateArticleBtn.disabled = !hasSelection;
      generateTweetBtn.disabled = !hasSelection;
      generateLinkedinBtn.disabled = !hasSelection;
      runPlaybookBtn.disabled = !hasSelection;
      publishArticleBtn.disabled = !hasSelection || !currentArticle;
      publishTweetBtn.disabled = !hasSelection || !currentTweetDraft;
      publishLinkedinBtn.disabled = !hasSelection || !currentLinkedinDraft;
      generateBriefBtn.disabled = !hasSelection || !isCertPresentation;
      publishBriefBtn.disabled = !hasSelection || !currentBriefText || !isCertPresentation;
    }

    async function fetchProviders() {
      try {
        const response = await fetch('/quest/api/providers');
        if (!response.ok) throw new Error('Impossible de récupérer les providers');
        providers = await response.json();
        renderProviders(providers);
      } catch (error) {
        setStatus(error.message, true);
      }
    }

    function resetGeneratedContent() {
      if (isLoading) {
        return;
      }
      currentArticle = '';
      currentTweetDraft = '';
      currentLinkedinDraft = '';
      currentBriefData = null;
      currentBriefText = '';
      articleOutput.textContent = DEFAULT_ARTICLE_TEXT;
      tweetOutput.textContent = DEFAULT_TWEET_TEXT;
      linkedinOutput.textContent = DEFAULT_LINKEDIN_TEXT;
      certBriefOutput.textContent = DEFAULT_BRIEF_TEXT;
      resetProgress();
      updateActionAvailability();
    }

    function renderProviders(list) {
      providerSelect.innerHTML = '<option value="">Choisir un provider…</option>';
      list.forEach(provider => {
        const option = document.createElement('option');
        option.value = provider.id;
        option.textContent = provider.name;
        providerSelect.appendChild(option);
      });
      updateActionAvailability();
    }

    function renderCertifications(list) {
      certSelect.innerHTML = '<option value="">Choisir une certification…</option>';
      list.forEach(cert => {
        const option = document.createElement('option');
        option.value = cert.id;
        option.textContent = cert.name;
        certSelect.appendChild(option);
      });
      updateActionAvailability();
    }

    providerSearch.addEventListener('input', () => {
      const query = providerSearch.value.toLowerCase();
      const filtered = providers.filter(provider => provider.name.toLowerCase().includes(query));
      renderProviders(filtered);
    });

    providerSelect.addEventListener('change', async () => {
      const providerId = providerSelect.value;
      resetGeneratedContent();
      certSearch.value = '';
      certifications = [];
      certSelect.disabled = !providerId;
      certSearch.disabled = !providerId;
      renderCertifications([]);
      updateActionAvailability();
      if (!providerId) {
        return;
      }
      try {
        setStatus('Chargement des certifications…');
        const response = await fetch(`/quest/api/certifications/${providerId}`);
        if (!response.ok) throw new Error('Erreur lors de la récupération des certifications');
        certifications = await response.json();
        renderCertifications(certifications);
        setStatus('');
      } catch (error) {
        setStatus(error.message, true);
      }
      updateActionAvailability();
    });

    certSearch.addEventListener('input', () => {
      const query = certSearch.value.toLowerCase();
      const filtered = certifications.filter(cert => cert.name.toLowerCase().includes(query));
      renderCertifications(filtered);
    });

    certSelect.addEventListener('change', () => {
      resetGeneratedContent();
      updateActionAvailability();
    });
    examUrlInput.addEventListener('input', updateActionAvailability);
    examUrlInput.addEventListener('change', resetGeneratedContent);
    topicTypeSelect.addEventListener('change', () => {
      resetGeneratedContent();
      updateActionAvailability();
    });

    generateBriefBtn.addEventListener('click', async () => {
      const selection = getSelectionPayload();
      if (!selection) {
        setStatus('Veuillez sélectionner un provider, une certification, un type de sujet et saisir le lien du test.', true);
        return;
      }
      if (selection.topic_type !== 'certification_presentation') {
        setStatus('La génération du JSON est réservée au type « Certification presentation ».', true);
        return;
      }

      try {

        setButtonLoading(generateBriefBtn, true, 'Génération…');
        certBriefOutput.textContent = 'Génération du JSON en cours…';
        toggleLoading(true);
        setStatus('Génération du JSON en cours…');
        const response = await fetch('/articles/generate-brief', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(selection)
        });
        const payload = await response.json();
        if (!response.ok) {
          throw new Error(payload.error || 'Erreur lors de la génération du JSON.');
        }
        currentBriefData = payload.brief || null;
        currentBriefText = currentBriefData ? JSON.stringify(currentBriefData, null, 2) : '';
        certBriefOutput.textContent = currentBriefText || 'Aucun JSON généré.';
        setStatus('Résumé JSON généré avec succès.');
      } catch (error) {
        const message = error instanceof Error ? error.message : String(error);
        currentBriefData = null;
        currentBriefText = '';
        certBriefOutput.textContent = DEFAULT_BRIEF_TEXT;
        setStatus(message, true);
      } finally {
        toggleLoading(false);
        setButtonLoading(generateBriefBtn, false);
        updateActionAvailability();
      }
    });

    publishBriefBtn.addEventListener('click', async () => {
      const selection = getSelectionPayload();
      if (!selection) {
        setStatus('Veuillez sélectionner un provider, une certification, un type de sujet et saisir le lien du test.', true);
        return;
      }
      if (!currentBriefData) {
        setStatus('Veuillez générer le JSON avant de le publier.', true);
        return;
      }

      try {

        setButtonLoading(publishBriefBtn, true, 'Publication…');
        toggleLoading(true);
        setStatus('Publication du JSON en cours…');
        const response = await fetch('/articles/publish-brief', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ ...selection, brief: currentBriefData })
        });
        const payload = await response.json();
        if (!response.ok) {
          throw new Error(payload.error || 'Erreur lors de la publication du JSON.');
        }
        setStatus('Résumé JSON publié avec succès dans la certification.');
      } catch (error) {
        const message = error instanceof Error ? error.message : String(error);
        setStatus(message, true);
      } finally {
        toggleLoading(false);
        setButtonLoading(publishBriefBtn, false);
        updateActionAvailability();
      }
    });

    generateArticleBtn.addEventListener('click', async () => {
      const selection = getSelectionPayload();

      if (!selection) {
        setStatus('Veuillez sélectionner un provider, une certification, un type de sujet et saisir le lien du test.', true);
        return;
      }

      try {
        toggleLoading(true);
        setStatus('Génération de l\'article en cours…');
        const response = await fetch('/articles/generate', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(selection)
        });
        const payload = await response.json();
        if (!response.ok) {
          throw new Error(payload.error || 'Erreur inconnue lors de la génération');
        }
        currentArticle = payload.article || '';
        articleOutput.textContent = currentArticle || 'Aucun contenu généré.';
        setStatus('Article généré avec succès.');

      } catch (error) {
        setStatus(error.message, true);
        currentArticle = '';
        articleOutput.textContent = 'L\'article n\'a pas pu être généré.';
      } finally {
        toggleLoading(false);
        updateActionAvailability();
      }
    });

    generateTweetBtn.addEventListener('click', async () => {
      const selection = getSelectionPayload();

      if (!selection) {
        setStatus('Veuillez sélectionner un provider, une certification, un type de sujet et saisir le lien du test.', true);
        return;
      }

      try {
        toggleLoading(true);
        setStatus('Génération du tweet en cours…');
        const response = await fetch('/articles/generate-tweet', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(selection)
        });
        const payload = await response.json();
        if (!response.ok) {
          throw new Error(payload.error || 'Erreur lors de la génération du tweet');
        }
        currentTweetDraft = payload.tweet || '';
        renderSocialBlock(
          tweetOutput,
          currentTweetDraft,
          false,
          null,
          null,
          'Aucun tweet généré.',
          null
        );
        setStatus('Tweet généré avec succès.');
      } catch (error) {
        const message = error instanceof Error ? error.message : String(error);
        currentTweetDraft = '';
        renderSocialBlock(
          tweetOutput,
          '',
          false,
          null,
          message,
          'Aucun tweet généré.',
          null
        );
        setStatus(message, true);
      } finally {
        toggleLoading(false);
        updateActionAvailability();
      }
    });

    generateLinkedinBtn.addEventListener('click', async () => {
      const selection = getSelectionPayload();

      if (!selection) {
        setStatus('Veuillez sélectionner un provider, une certification, un type de sujet et saisir le lien du test.', true);
        return;
      }

      try {
        toggleLoading(true);
        setStatus('Génération du post LinkedIn en cours…');
        const response = await fetch('/articles/generate-linkedin', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(selection)
        });
        const payload = await response.json();
        if (!response.ok) {
          throw new Error(payload.error || 'Erreur lors de la génération du post LinkedIn');
        }
        currentLinkedinDraft = payload.linkedin_post || '';
        renderSocialBlock(
          linkedinOutput,
          currentLinkedinDraft,
          false,
          null,
          null,
          'Aucun post LinkedIn généré.',
          null
        );
        setStatus('Post LinkedIn généré avec succès.');
      } catch (error) {
        const message = error instanceof Error ? error.message : String(error);
        currentLinkedinDraft = '';
        renderSocialBlock(
          linkedinOutput,
          '',
          false,
          null,
          message,
          'Aucun post LinkedIn généré.',
          null
        );
        setStatus(message, true);
      } finally {
        toggleLoading(false);
        updateActionAvailability();
      }
    });

    publishArticleBtn.addEventListener('click', async () => {
      const selection = getSelectionPayload();
      if (!selection) {
        setStatus('Veuillez sélectionner un provider, une certification, un type de sujet et saisir le lien du test.', true);
        return;
      }
      if (!currentArticle) {
        setStatus('Veuillez générer l\'article avant de le publier.', true);
        return;
      }

      const payloadToSend = { ...selection, article: currentArticle };

      try {
        toggleLoading(true);
        setStatus('Publication de l\'article en cours…');
        const response = await fetch('/articles/publish', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payloadToSend)
        });
        const payload = await response.json();
        if (!response.ok) {
          throw new Error(payload.error || 'Erreur lors de la publication de l\'article');
        }

        const articleIdInfo = payload.blog_id ? ` (ID ${payload.blog_id})` : '';
        setStatus(`Article publié avec succès${articleIdInfo}.`);
      } catch (error) {
        const message = error instanceof Error ? error.message : String(error);
        setStatus(message, true);
      } finally {
        toggleLoading(false);
        updateActionAvailability();
      }
    });

    runPlaybookBtn.addEventListener('click', async () => {
      const selection = getSelectionPayload();
      if (!selection) {
        setStatus('Veuillez sélectionner un provider, une certification, un type de sujet et saisir le lien du test.', true);
        return;
      }
      selection.add_image = addImageCheckbox.checked;

      let reader;
      let streamCompleted = false;
      let streamFailed = false;

      try {
        toggleLoading(true);
        resetProgress();
        setProgress(0, 'Démarrage du runbook…');
        setStatus('Démarrage du runbook…');
        const response = await fetch('/articles/run-playbook', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(selection)
        });
        if (!response.ok) {
          const payload = await response.json().catch(() => ({}));
          throw new Error(payload.error || 'Erreur inconnue lors du runbook.');
        }
        if (!response.body || typeof response.body.getReader !== 'function') {
          const payload = await response.json().catch(() => ({}));
          throw new Error(payload.error || 'Flux de progression indisponible.');
        }

        reader = response.body.getReader();
        const decoder = new TextDecoder();
        let buffer = '';

        while (true) {
          const { value, done } = await reader.read();
          if (done) {
            break;
          }

          buffer += decoder.decode(value, { stream: true });
          const lines = buffer.split('\n');
          buffer = lines.pop() || '';

          for (const rawLine of lines) {
            const line = rawLine.trim();
            if (!line) {
              continue;
            }

            let event;
            try {
              event = JSON.parse(line);
            } catch (parseError) {
              console.warn('Événement runbook invalide:', parseError, line);
              continue;
            }

            if (event.type === 'progress') {
              const ratio = typeof event.progress === 'number'
                ? event.progress
                : (event.total_steps ? event.step / event.total_steps : 0);
              setProgress(ratio, event.message || '', false);
              if (event.message) {
                setStatus(event.message);
              }
            } else if (event.type === 'complete') {
              const ratio = typeof event.progress === 'number' ? event.progress : 1;
              setProgress(ratio, event.message || 'Runbook terminé.', false);
              setStatus(event.message || 'Runbook terminé.');

              currentArticle = event.article || '';
              articleOutput.textContent = currentArticle || 'Aucun contenu généré.';

              if (event.brief_included) {
                currentBriefData = event.brief || null;
                currentBriefText = currentBriefData
                  ? JSON.stringify(currentBriefData, null, 2)
                  : '';
                certBriefOutput.textContent = currentBriefText || 'Aucun JSON généré.';
              } else {
                currentBriefData = null;
                currentBriefText = '';
                certBriefOutput.textContent = DEFAULT_BRIEF_TEXT;
              }

              currentLinkedinDraft = event.linkedin_post || '';
              renderSocialBlock(
                linkedinOutput,
                currentLinkedinDraft,
                Boolean(event.linkedin_published),
                event.linkedin_status_code,
                event.linkedin_error,
                'Aucun post LinkedIn généré.',
                event.linkedin_image
              );

              streamCompleted = true;
            } else if (event.type === 'error') {
              const ratio = typeof event.progress === 'number'
                ? event.progress
                : (event.total_steps ? event.step / event.total_steps : 0);
              setProgress(ratio, event.message || 'Erreur lors du runbook.', true);
              setStatus(event.message || 'Erreur lors du runbook.', true);
              streamFailed = true;
            }

            if (streamCompleted || streamFailed) {
              break;
            }
          }

          if (streamCompleted || streamFailed) {
            break;
          }
        }
      } catch (error) {
        const message = error instanceof Error ? error.message : String(error);
        setStatus(message, true);
        setProgress(0, message, true);
        streamFailed = true;
      } finally {
        if (reader) {
          try {
            await reader.cancel();
          } catch (cancelError) {
            console.warn('Impossible d\'annuler le flux du runbook:', cancelError);
          }
        }
        toggleLoading(false);
      }
    });

    publishTweetBtn.addEventListener('click', async () => {
      const selection = getSelectionPayload();
      if (!selection) {
        setStatus('Veuillez sélectionner un provider, une certification, un type de sujet et saisir le lien du test.', true);
        return;
      }
      if (!currentTweetDraft) {
        setStatus('Veuillez générer le tweet avant de le publier.', true);
        return;
      }
      selection.add_image = addImageCheckbox.checked;
      selection.tweet = currentTweetDraft;
      try {
        toggleLoading(true);
        setStatus('Publication du tweet en cours…');
        const response = await fetch('/articles/publish-tweet', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(selection)
        });
        const payload = await response.json();
        if (!response.ok) {
          throw new Error(payload.error || 'Erreur lors de la publication du tweet');
        }

        currentTweetDraft = payload.tweet || currentTweetDraft;
        renderSocialBlock(
          tweetOutput,
          currentTweetDraft,
          Boolean(payload.tweet_published),
          payload.tweet_status_code,
          payload.tweet_error,
          'Aucun tweet généré.',
          payload.tweet_image
        );

        if (payload.tweet_published) {
          setStatus('Tweet publié avec succès.');
        } else {
          setStatus('Tweet généré mais non publié.', true);
        }
      } catch (error) {
        const message = error instanceof Error ? error.message : String(error);
        setStatus(message, true);
      } finally {
        toggleLoading(false);
        updateActionAvailability();
      }
    });

    publishLinkedinBtn.addEventListener('click', async () => {
      const selection = getSelectionPayload();
      if (!selection) {
        setStatus('Veuillez sélectionner un provider, une certification, un type de sujet et saisir le lien du test.', true);
        return;
      }
      if (!currentLinkedinDraft) {
        setStatus('Veuillez générer le post LinkedIn avant de le publier.', true);
        return;
      }
      selection.add_image = addImageCheckbox.checked;
      selection.linkedin_post = currentLinkedinDraft;
      try {
        toggleLoading(true);
        setStatus('Publication du post LinkedIn en cours…');
        const response = await fetch('/articles/publish-linkedin', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(selection)
        });
        const payload = await response.json();
        if (!response.ok) {
          throw new Error(payload.error || 'Erreur lors de la publication du post LinkedIn');
        }

        currentLinkedinDraft = payload.linkedin_post || currentLinkedinDraft;
        renderSocialBlock(
          linkedinOutput,
          currentLinkedinDraft,
          Boolean(payload.linkedin_published),
          payload.linkedin_status_code,
          payload.linkedin_error,
          'Aucun post LinkedIn généré.',
          payload.linkedin_image
        );

        if (payload.linkedin_published) {
          setStatus('Post LinkedIn publié avec succès.');
        } else {
          setStatus('Post LinkedIn généré mais non publié.', true);
        }
      } catch (error) {
        const message = error instanceof Error ? error.message : String(error);
        setStatus(message, true);
      } finally {
        toggleLoading(false);
        updateActionAvailability();
      }
    });

    function resetProgress() {
      if (!runbookProgress || !runbookProgressBar || !runbookProgressLabel) {
        return;
      }
      runbookProgressBar.style.width = '0%';
      runbookProgressBar.classList.remove('error');
      runbookProgressLabel.textContent = '';
      runbookProgressLabel.classList.remove('error');
      runbookProgress.classList.add('hidden');
    }

    function setProgress(value, message = '', isError = false) {
      if (!runbookProgress || !runbookProgressBar || !runbookProgressLabel) {
        return;
      }
      const ratio = Math.max(0, Math.min(1, Number(value) || 0));
      runbookProgress.classList.remove('hidden');
      runbookProgressBar.style.width = `${Math.round(ratio * 100)}%`;
      runbookProgressBar.classList.toggle('error', Boolean(isError));
      runbookProgressLabel.textContent = message || '';
      runbookProgressLabel.classList.toggle('error', Boolean(isError));
    }

    function toggleLoading(state) {
      isLoading = Boolean(state);
      if (isLoading) {
        generateArticleBtn.disabled = true;
        generateTweetBtn.disabled = true;
        generateLinkedinBtn.disabled = true;
        runPlaybookBtn.disabled = true;
        publishArticleBtn.disabled = true;
        publishTweetBtn.disabled = true;
        publishLinkedinBtn.disabled = true;
        generateBriefBtn.disabled = true;
        publishBriefBtn.disabled = true;
      } else {
        updateActionAvailability();
      }
    }

    function setStatus(message, isError = false) {
      statusArea.textContent = message;
      statusArea.style.color = isError ? '#f87171' : 'var(--text-muted)';
    }

    function setButtonLoading(button, isLoading, loadingLabel) {
      if (!button) {
        return;
      }

      if (isLoading) {
        if (!button.dataset.originalLabel) {
          button.dataset.originalLabel = button.textContent;
        }
        button.textContent = loadingLabel || button.dataset.originalLabel;
        button.classList.add('is-loading');
      } else {
        const original = button.dataset.originalLabel;
        if (original) {
          button.textContent = original;
        }
        button.classList.remove('is-loading');
      }
    }

    fetchProviders();
    updateActionAvailability();
  </script>
</body>
</html>
